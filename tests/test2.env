
// Open-a-closed-door then move-through-an-open-door test

//import "test1-import.env"
//import "test2.txt"

@defines
//#defineprop closed CLOSEDNAMESUB

@classes 

class test extends Object {
	constructor() { }
	
	prop abc = { 
		println("test") 
		return true 
	} 
}

class Object extends Any {
	constructor() { }
	prop abcTestProp = "TestProp123"		// Default property value	
	
}
class Door extends Object {
	prop abcTestProp = "TestProp456"		// Default property value	
	
	prop exampleProp = { 
		println("Door Object") 
		return 1234
	} 
}

class Room extends Object {
	prop exampleProp = { 
		println("Room Object") 
		return 3456
	} 
}
class Agent extends Object {
	prop inheritTest = { return "inherit!" }
	//prop inheritTest = { return "inherit!" }		// Throw duplicate error
}

class Test extends Agent {
	//prop inheritTest = { return "inherit123!" }		// Throw no-override error
	override prop inheritTest = { return "inherit456!" }		// Valid
}

@predicates 

/*
def atOld(thing:Agent, location:Room) = {
    get {
        println("Checking if thing in location...")
        if (thing in location) {
            println("---Thing is in location...")
            return true
        }
        return false        
    }
    set {
        moveObj(thing to location)
    }
}
*/

def at(thing:Any, location:Any) = {
    get {
		//return 123			// Test for throwing a return type error (expected: boolean, actual: number)
        println("Checking if thing in location...")
        if (thing in location) {
            println("---Thing is in location...")
            return true
        }
        return false        
    }
    set {
        moveObj(thing to location)
    }
}

def moveThroughDoor(agent:Agent, door:Door) = {
    get {
        return false
    }
    set {
        moveObj(agent to door.connectsTo)
    }
}

def isClosed(door:Door) = {     
    get { 
        return door.closed
    }
    set {
        door.closed = true
        println("Door set to closed.")
    }
}

def isOpen(door:Door) = {
    get { 
        if (door.closed == false) { return true }
        return false
        //return !door.closed       // TODO: Add a negation marker
    }
    set {
        door.closed = false
        println("Door set to open.")
    }
}

@actions
action openDoor(agent:Agent, door:Door)
action testAction(agent:Agent)

@rules

// TODO: Implement strong type checking for rules, checking arguments (check all predicate arguments are populated, check no predicate arguments are missing, etc) 

//rule open_closed_doors(d:Door, a:Agent, r:Room) :: at(thing=a, location=r) * at(thing=d, location=r) * isClosed(door=d) -o isOpen(door=d)
rule open_closed_doors(d:Door, a:Agent, r:Room) :: at(thing=a, location=r) * at(thing=d, location=r) * isClosed(door=d) * openDoor(agent=a, door=d) -o isOpen(door=d)
//rule move_through_door(d:Door, a:Agent, r:Room) :: at(thing=a, location=r) * at(thing=d, location=r) * isOpen(door=d) -o moveThroughDoor(agent=a, door=d)
rule move_through_door(d:Door, a:Agent, r:Room) :: at(thing=a, location=r) * at(thing=d, location=r) * isOpen(door=d) -o moveThroughDoor(agent=a, door=d) * testAction(agent=a)
//rule errortest(d:Door, a:Agent, r:Room) :: at(thing=a) * isOpen(door=d, window=w) -o moveThroughDoor(agent=a, light=l)


@init

println("test")

var room1 = new Room
room1.name = "Office"
addObjToWorld(room1)

var room2 = new Room
room2.name = "Living Room"
addObjToWorld(room2)

var room3 = new Room
room3.name = "Hallway"
addObjToWorld(room3)

var doorR1R3 = new Door
doorR1R3.name = "Door from Living Room to Hallway"
doorR1R3.closed = true
doorR1R3.connectsTo = room3
moveObj(doorR1R3 to room1)

var agent = new Agent
agent.name = "The Agent"
moveObj(agent to room1)

agent.inheritTest = "failure test"		// Should throw a warning that this is overwriting an auto-populated property

requestAction openDoor(agent=agent, door=doorR1R3)
//requestAction openDoor(agent=room1, door=doorR1R3)		// This should create a type error

println("##Built-in")
for (i <- 0 until 10) {
	var a = "123.456"
	println( i )
	println( a )
	println( i + round(a) )
	println( i + floor(a) )
	println( "num: " + str(i) )
}
for (obj <- room1) {
	println(obj)
}

println ( min(10, 20, 30) )
println ( max(10, 20, 30) )
println ( pow(10, 2) )
println ( sqrt(9) )
println ( "abc" + str(sin(90)) )		// Nested

//exit(1)
