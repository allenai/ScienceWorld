package language.runtime.runners

import language.model.{ClassDef, ParamList, ParamSigList, PredicateDef}
import language.runtime.Interpreter
import language.struct._

import scala.collection.mutable
import scala.util.control.Breaks._


// MainInterpreter is just passed to populate any println statements for output -- not as the interpreter to run the predicates on.
class PredicateRunner(val predicates:Array[PredicateDef], val objectTreeRoot:EnvObject, val definesLUT:Map[String, String], val classLUT:Map[String, ClassDef], val taxonomy:Taxonomy, val actionRunner:ActionRunner, val mainInterpreter:Interpreter, val debugOutput:Boolean = false) {
  val objsByType = PredicateRunner.collectObjectsByType(objectTreeRoot, taxonomy)
  // A LUT of (pred_arg) hashcodes, followed by their evaluation, results (true/false).  Also includes keys/values from action requests that have been made this timestamp.
  val getterResultLUT = this.runAllPredicates(objsByType) ++ actionRunner.getActionsThisTimestep()     // Key: hashcode for a given predicate+argument set, value: Whether the getter evaluated as true or false given those arguments


  println ("PredicateRunner (" + getterResultLUT.size + " values stored...)")
  val keys = this.getterResultLUT.keySet.toArray
  if (debugOutput) {
    for (i <- 0 until math.min(10, getterResultLUT.size)) {
      println("\t" + i + " " + keys(i) + "\t" + this.getterResultLUT(keys(i)))
    }
  }


  // Lookup the result of a predicate that has been run
  def getResult(key:String):Boolean = {
    if (!this.getterResultLUT.contains(key)) return false
    return this.getterResultLUT(key)
  }


  /*
  //## DEBUG: Run all predicates
  println ("Predicates: ")
  for (predicate <- predicates) {
    println(predicate.toString())

    // Create assignments
    //## Debug
    val obj1 = new EnvObject()
    obj1.setName("testObj1")
    obj1.setType("type1")

    val obj2 = new EnvObject()
    obj2.setName("testObj2")
    obj2.setType("type2")

    val assignments = new VariableLUT()
    assignments.set("a", new DynamicValue(obj1))
    assignments.set("c", new DynamicValue(obj2))

    // Run
    //evaluateGetter(predicate, new VariableLUT())
    evaluateGetter(predicate, assignments)
  }
   */


  // Runs all the predicates (individually), with all the possible valid combinations of objects that can populate their arguments.
  // Stores the value in a hashmap (key = generated by mkPredStr, value = getter result)
  def runAllPredicates(objsByType:Map[String, Set[EnvObject]]): mutable.Map[String, Boolean] = {
    val getterResults = mutable.Map[String, Boolean]()

    val startTime = System.currentTimeMillis()

    for (predicate <- predicates) {
      val iter = new ParamIterator(predicate.paramSigList, objsByType)

      breakable {
        while (true) {
          // First, get a valid combination of objects that this predicate can be run with
          val combo = iter.next()
          if (combo.isEmpty) break()        // Break when no more valid combinations are available

          // Create string key for this run
          val argObjs = combo.get
          val strKey = PredicateRunner.mkPredStr(predicate.name, argObjs)

          // Pack the assignments
          val assignments = new ScopedVariableLUT()
          for (i <- 0 until predicate.paramSigList.parameters.length) {
            val param = predicate.paramSigList.parameters(i)
            val paramName = param.name
            assignments.set(paramName, new DynamicValue(argObjs(i)))
          }

          // Run the predicate with these arguments
          val result = this.evaluateGetter(predicate, assignments)

          // Store the result
          getterResults(strKey) = result
        }
      }

    }

    val endTime = System.currentTimeMillis()
    val deltaTime = endTime - startTime
    println (" * runAllPredicates(): Completed in " + deltaTime + " msec")

    // Return
    getterResults
  }




  def evaluateGetter(predicate:PredicateDef, assignments:ScopedVariableLUT): Boolean = {
    // Check that the assignments match the predicate signature
    val (success, errStr) = PredicateRunner.checkParamList(predicate.paramSigList, assignments, taxonomy, callNameForErrMsg = "predicate (" + predicate.name + ")")

    // Check that a getter has been defined
    if (predicate.getter.isEmpty) return false

    // Run the getter
    def getterCode = predicate.getter.get
    val interpreter = new Interpreter(definesLUT, classLUT, actionRunner)
    interpreter.setVariableLUT(assignments)
    interpreter.setObjectTreeRoot(objectTreeRoot)
    val wcResult = interpreter.walkOneStep( getterCode )

    mainInterpreter.mergeConsoleOutput(interpreter)

    // Check for failure
    if (!wcResult.success) {
      sys.exit(1)
    }

    // Check that the evaluation ended in a return value, rather than nothing.
    if (wcResult.returnValue.isEmpty) {
      // Error, this predicate does not appear to return a value
      var errStr = "ERROR: Predicate (" + predicate.name + ") did not return a value. "
      if (predicate.statements.isDefined) {
        if (getterCode.size > 0) {
          errStr += "(around line " + getterCode(0).pos.line + ")"
        }

      }
      println(errStr)
      sys.exit(1)
    }

    // Check that the type of the value is valid
    if (!wcResult.returnValue.get.isBoolean()) {
      println ("ERROR: Predicate (" + predicate.name + ") getter appears to have an incorrect return type around line " + predicate.pos.line + ".")
      println ("ERROR: Expected expression value of type (" + DynamicValue.TYPE_BOOLEAN + "), instead found type (" + wcResult.returnValue.get.getTypeStr() + ")")
      sys.exit(1)
    }

    // Return the value
    return wcResult.returnValue.get.getBoolean().get
  }


  def runSetter(predicate:PredicateDef, assignments:ScopedVariableLUT): Array[ChangeLog] = {
    // Check that a getter has been defined
    if (predicate.setter.isEmpty) return Array.empty[ChangeLog]

    // Run the getter
    def setterCode = predicate.setter.get
    val interpreter = new Interpreter(definesLUT, classLUT, actionRunner)
    interpreter.setVariableLUT(assignments)
    interpreter.setObjectTreeRoot(objectTreeRoot)

    val wcResult = interpreter.walkOneStep( setterCode )

    mainInterpreter.mergeConsoleOutput(interpreter)

    // Check for failure
    if (!wcResult.success) {
      println ("ERROR Encountered when running setter for predicate (" + predicate.name + ") around line " + predicate.pos.line + ".")
      println (predicate.pos.longString)
      println ("Variable dump:")
      println (assignments.toString())
      sys.exit(1)
    }

    // Return changelog
    return interpreter.changeLog.toArray

  }




}

object PredicateRunner {

  /*
   * Checking/Evaluating Parameter Lists
   */
  // Given a parameter list (e.g. for running a class constructor), and a variableLUT, create a new VariableLUT with those assignments.
  def packAssignments(paramList:ParamList, currentLUT:ScopedVariableLUT): (Boolean, String, ScopedVariableLUT) = {
    val assignments = new ScopedVariableLUT()
    for (param <- paramList.parameters) {
      val paramName = param.name
      val takeFromVariable = param.value

      // If the variable can't be found, then throw an error.
      if (!currentLUT.contains(takeFromVariable)) return (false, "ERROR: Unable to assign (" + takeFromVariable + "): Unknown variable name, around line " + param.pos.line + ".\n" + param.pos.longString, assignments)
      val varValue = currentLUT.get(takeFromVariable)

      // Create the reference from the old variable name to the new variable name
      assignments.set(paramName, varValue.get)
    }

    // Return
    return (true, "", assignments)
  }

  // Check that a given set of variable assignments (input) meets the requirements for a parameter signature list (from a class constructor, predicate signature, etc).
  def checkParamList(paramSigList:ParamSigList, assignments:ScopedVariableLUT, taxonomy:Taxonomy, callNameForErrMsg:String): (Boolean, String) = {
    // Check that the assignments match the predicate signature
    for (parameter <- paramSigList.parameters) {
      // Step 1: First, check that the parameter name is present in the variable LUT assignments
      if (!assignments.contains(parameter.name)) {
        val errStr = "ERROR: Call to " + callNameForErrMsg + " did not include a required parameter (" + parameter.name + ":" + parameter.objType + ")"
        //println(errStr)
        return (false, errStr)
      }
      // Step 2: Then, check that the variable passed to this parameter is an object
      val variableValue = assignments.get(parameter.name).get
      if (!variableValue.isObject()) {
        val errStr = "ERROR: Call to " + callNameForErrMsg + " includes a variable (" + parameter.name + ") that is not of required type (" + DynamicValue.TYPE_OBJECT + " expected, " + variableValue.getTypeStr() + " found)."
        //println(errStr)
        return (false, errStr)
      }
      // Step 3: Then, check that the variable passed to this parameter is the correct type

      // Step 3A: Get a list of hierarchical types that are valid for this object (if it's type is in the taxonomy), OR default back to just that single type if the object isn't listed in the taxonomy
      val objType = variableValue.getObject().get.getType()
      val (success, errorStr, validTypes_) = taxonomy.getHypernyms(objType)
      var validTypes = validTypes_
      if (!success) validTypes = Array(objType)
      // Step 3B: Do the check
      if (!validTypes.contains(parameter.objType)) {
        val errStr = "ERROR: Call to " + callNameForErrMsg + " includes a variable (" + parameter.name + ") that is not of required type (expected: " + parameter.objType + ", found: " + variableValue.getObject().get.getType() + " found)."
        //println(errStr)
        return (false, errStr)
      }
    }

    // If we reach here, all required parameters have been passed, and they are the correct type.
    return (true, "")
  }

  /*
   * Helper functions (collecting objects from the object tree into more easily traversed data structures)
   */

  // Collect all objects in the object tree into a flat set
  def collectObjects(objectTreeRoot:EnvObject):mutable.Set[EnvObject] = {
    val out = mutable.Set[EnvObject]()

    // Step 1: Add this object
    if (!out.contains(objectTreeRoot)) out.add(objectTreeRoot)

    // Step 2: Add children recursively
    for (obj <- objectTreeRoot.getContainedObjects()) {
      if (!out.contains(obj)) {
        out ++= this.collectObjects(obj)
      }
    }

    // Return
    out
  }

  // Collect all objects in the object tree, arranged by type (stored in a hashmap)
  def collectObjectsByType(objectTreeRoot:EnvObject, taxonomy:Taxonomy):Map[String, Set[EnvObject]] = {
    val out = mutable.Map[String, Set[EnvObject]]()

    val allObjects = this.collectObjects(objectTreeRoot)
    for (obj <- allObjects) {
      val typeKeyBase = obj.getType()   // Get the type the object is defined as

      // Get any hypernyms that base type might have
      val (success, errorStrs, hyponyms) = taxonomy.getHypernyms(typeKeyBase)
      var typeKeys = Array[String](typeKeyBase)
      if (success) typeKeys = hyponyms // The object does exist in the taxonomy

      // For each inherited type, add it to the LUT
      for (typeKey <- typeKeys) {
        if (!out.contains(typeKey)) out(typeKey) = Set[EnvObject]()
        out(typeKey) += obj
      }
    }

    return out.toMap
  }


  /*
   * Helper functions (hashcodes for objects/arguments)
   */
  // Creates a string based on the object uuids from the objects passed in
  def mkPredStr(predName:String, argObjs:Array[EnvObject]):String = {
    return predName + "_" + mkArgStr(argObjs)
  }

  // Creates a string based on the object uuids from the objects passed in
  def mkArgStr(argObjs:Array[EnvObject]):String = {
    val uuids = argObjs.map(_.uuid)
    uuids.mkString("_")
  }


}
